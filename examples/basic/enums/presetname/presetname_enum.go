// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package presetname

import (
	"database/sql/driver"
	"errors"
	"fmt"
	"strconv"
)

const (
	// Gemini25FlashNonThinking is a PresetName of type Gemini 2.5 Flash Non-Thinking.
	Gemini25FlashNonThinking PresetName = "Gemini 2.5 Flash Non-Thinking"
	// Gemini25FlashThinking is a PresetName of type Gemini 2.5 Flash Thinking.
	Gemini25FlashThinking PresetName = "Gemini 2.5 Flash Thinking"
	// Gemini25FlashNonThinkingSearch is a PresetName of type Gemini 2.5 Flash Non-Thinking Search.
	Gemini25FlashNonThinkingSearch PresetName = "Gemini 2.5 Flash Non-Thinking Search"
	// Gemini25ProLow is a PresetName of type Gemini 2.5 Pro Low.
	Gemini25ProLow PresetName = "Gemini 2.5 Pro Low"
	// Gemini25ProLowSearch is a PresetName of type Gemini 2.5 Pro Low Search.
	Gemini25ProLowSearch PresetName = "Gemini 2.5 Pro Low Search"
	// Gemini25ProHigh is a PresetName of type Gemini 2.5 Pro High.
	Gemini25ProHigh PresetName = "Gemini 2.5 Pro High"
	// Gemini25ProHighSearch is a PresetName of type Gemini 2.5 Pro High Search.
	Gemini25ProHighSearch PresetName = "Gemini 2.5 Pro High Search"
	// GPT4OSearch is a PresetName of type GPT 4o Search.
	GPT4OSearch PresetName = "GPT 4o Search"
	// GPT4OMiniSearch is a PresetName of type GPT 4o Mini Search.
	GPT4OMiniSearch PresetName = "GPT 4o Mini Search"
	// DeepseekV3 is a PresetName of type Deepseek V3.
	DeepseekV3 PresetName = "Deepseek V3"
	// DeepseekV31 is a PresetName of type Deepseek V3.1.
	DeepseekV31 PresetName = "Deepseek V3.1"
)

var ErrInvalidPresetName = errors.New("not a valid PresetName")

// String implements the Stringer interface.
func (x PresetName) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x PresetName) IsValid() bool {
	_, err := ParsePresetName(string(x))
	return err == nil
}

var _PresetNameValue = map[string]PresetName{
	"Gemini 2.5 Flash Non-Thinking":        Gemini25FlashNonThinking,
	"Gemini 2.5 Flash Thinking":            Gemini25FlashThinking,
	"Gemini 2.5 Flash Non-Thinking Search": Gemini25FlashNonThinkingSearch,
	"Gemini 2.5 Pro Low":                   Gemini25ProLow,
	"Gemini 2.5 Pro Low Search":            Gemini25ProLowSearch,
	"Gemini 2.5 Pro High":                  Gemini25ProHigh,
	"Gemini 2.5 Pro High Search":           Gemini25ProHighSearch,
	"GPT 4o Search":                        GPT4OSearch,
	"GPT 4o Mini Search":                   GPT4OMiniSearch,
	"Deepseek V3":                          DeepseekV3,
	"Deepseek V3.1":                        DeepseekV31,
}

// ParsePresetName attempts to convert a string to a PresetName.
func ParsePresetName(name string) (PresetName, error) {
	if x, ok := _PresetNameValue[name]; ok {
		return x, nil
	}
	return PresetName(""), fmt.Errorf("%s is %w", name, ErrInvalidPresetName)
}

// MarshalText implements the text marshaller method.
func (x PresetName) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *PresetName) UnmarshalText(text []byte) error {
	tmp, err := ParsePresetName(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var errPresetNameNilPtr = errors.New("value pointer is nil") // one per type for package clashes

var sqlIntPresetNameMap = map[int64]PresetName{
	0:  Gemini25FlashNonThinking,
	1:  Gemini25FlashThinking,
	2:  Gemini25FlashNonThinkingSearch,
	3:  Gemini25ProLow,
	4:  Gemini25ProLowSearch,
	5:  Gemini25ProHigh,
	6:  Gemini25ProHighSearch,
	7:  GPT4OSearch,
	8:  GPT4OMiniSearch,
	9:  DeepseekV3,
	10: DeepseekV31,
}

var sqlIntPresetNameValue = map[PresetName]int64{
	Gemini25FlashNonThinking:       0,
	Gemini25FlashThinking:          1,
	Gemini25FlashNonThinkingSearch: 2,
	Gemini25ProLow:                 3,
	Gemini25ProLowSearch:           4,
	Gemini25ProHigh:                5,
	Gemini25ProHighSearch:          6,
	GPT4OSearch:                    7,
	GPT4OMiniSearch:                8,
	DeepseekV3:                     9,
	DeepseekV31:                    10,
}

func lookupSqlIntPresetName(val int64) (PresetName, error) {
	x, ok := sqlIntPresetNameMap[val]
	if !ok {
		return x, fmt.Errorf("%v is not %w", val, ErrInvalidPresetName)
	}
	return x, nil
}

// Scan implements the Scanner interface.
func (x *PresetName) Scan(value interface{}) (err error) {
	if value == nil {
		*x = PresetName("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x, err = lookupSqlIntPresetName(v)
	case string:
		*x, err = ParsePresetName(v)
	case []byte:
		if val, verr := strconv.ParseInt(string(v), 10, 64); verr == nil {
			*x, err = lookupSqlIntPresetName(val)
		} else {
			// try parsing the value as a string
			*x, err = ParsePresetName(string(v))
		}
	case PresetName:
		*x = v
	case int:
		*x, err = lookupSqlIntPresetName(int64(v))
	case *PresetName:
		if v == nil {
			return errPresetNameNilPtr
		}
		*x = *v
	case uint:
		*x, err = lookupSqlIntPresetName(int64(v))
	case uint64:
		*x, err = lookupSqlIntPresetName(int64(v))
	case *int:
		if v == nil {
			return errPresetNameNilPtr
		}
		*x, err = lookupSqlIntPresetName(int64(*v))
	case *int64:
		if v == nil {
			return errPresetNameNilPtr
		}
		*x, err = lookupSqlIntPresetName(int64(*v))
	case float64: // json marshals everything as a float64 if it's a number
		*x, err = lookupSqlIntPresetName(int64(v))
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errPresetNameNilPtr
		}
		*x, err = lookupSqlIntPresetName(int64(*v))
	case *uint:
		if v == nil {
			return errPresetNameNilPtr
		}
		*x, err = lookupSqlIntPresetName(int64(*v))
	case *uint64:
		if v == nil {
			return errPresetNameNilPtr
		}
		*x, err = lookupSqlIntPresetName(int64(*v))
	case *string:
		if v == nil {
			return errPresetNameNilPtr
		}
		*x, err = ParsePresetName(*v)
	default:
		return errors.New("invalid type for PresetName")
	}

	return
}

// Value implements the driver Valuer interface.
func (x PresetName) Value() (driver.Value, error) {
	val, ok := sqlIntPresetNameValue[x]
	if !ok {
		return nil, ErrInvalidPresetName
	}
	return int64(val), nil
}
